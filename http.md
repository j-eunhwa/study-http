# Real World HTTP

## 1章 - HTTPの基本の4要素
### メソッド
- **GET** → サーバーに対して、ヘッダーとコンテンツを要求
- **HEAD** → サーバーに対して、ヘッダーのみを要求
- **POST** → 新しいドキュメントを投稿
- **PUT** → すでに存在するURLのドキュメントを更新
- **DELETE** → 指定されたURLのドキュメントを削除する。削除に成功すると、削除されたURLは無効になる

### ヘッダー
HTTPのヘッダーは、リクエスト、レスポンスの両方で使われています。ヘッダーはサーバーとクライアント間で、追加情報、指示や命令、お願いなどを書く場です。
- クライアントがサーバーに送るヘッダー
    - **User-Agent**<br>
    クライアントが自分のアプリケーション名を入れるところ。サーバーはここの名前を見て、レスポンスを切り替えることもある。フィーチャーフォンやスマートフォン、PCの場合もブラウザの種類やバージョンを見分けることができる。ただし歴史的な経緯もあり、多くのブラウザが「Mozillaのブラウザのようで、Safariのような、Chromeみたいな、Edge」というように、自分が持つ機能を内包する他のブラウザを列挙する形式で名乗る。
    - **Referer**<br>
    サーバー側で参考にするための追加情報。クライアントがリクエストを送る時に見ていたページのURLを送る。ページの参照元をサーバーが参照するのに用いる。セキュリティのために仕様が当初よりも大きく変更された。
    - **Authorization**<br>
    特別なクライアントにだけ通信を許可する際、認証情報をサーバーに伝える。RFCでいくつかの標準的な形式（Basic/Digest/Bearer）を定めているが、アマゾンウェブサービスやGitHubAPIなど、ウェブサービス独自の表記を求められることもある。
- サーバーからクライアントに返す時に付与するヘッダー
    - **Content-Type**<br>
    ファイルの種類を指定。ここにはMIMEタイプと呼ばれる識別子を記述する。
    - **Content-Length**<br>
    ボディのサイズ。もし次のヘッダーで紹介する圧縮が行われている場合は圧縮後のサイズが入る
    - **Content-Encoding**<br>
    何らかの圧縮が行われた場合に圧縮形式を説明する
    - **Date**<br>
    ドキュメントの日時

### ボディ
ヘッダーとの間に空行を挟んで、それ以降がすべてボディになります。ただし、送信時のデータを格納するフォーマットが2種類あり、用途によって使い分ける必要があります。
```json
ヘッダー1: ヘッダーの値1
ヘッダー2: ヘッダーの値2
Content-Length: ボディのバイト数

ここから指定されたバイト数分ボディが含まれる
```

### ステータス
- **100番台** → 処理中の情報の伝達。1xx系は特殊な用途で使う。4章のHTTP/1.1の説明に登場
- **200番台** → 成功時のレスポンス。一番使用されるステータスは200 OKで、正常終了
- **300番台** → サーバーからクライアントへの命令。エラーではなく、正常処理の範疇。リダイレクトや、キャッシュの利用を指示
- **400番台** → クライアントから送られたリクエストにおかしなことがある場合に渡される
- **500番台** → サーバー内部でエラーが発生した場合にクライアントに送付される

## 2章 - ブラウザの基本機能の裏側
### シンプルなフォームの送信（x-www-form-urlencoded）
キーと値は、その間に '=' がある形でキーと値の組になり、 '&' で区切られてエンコードされます。キーや値の英数字以外の文字は、パーセントエンコーディングされます。このため、このタイプはバイナリデータを扱うのには向きません。
```html
<form method="POST">
    <input name="title">
    <input name="author">
    <input type="submit">
</form>
```

### フォームを使ったファイルの送信（multipart/form-data）
ボディは次のようになっています。区切り文字列で2つのブロックに分かれていることが分かります。また、末尾には、区切り文字列 + --という文字列の行があります。それぞれのブロック内も、HTTPのような構成になっており、「ヘッダー + 空行 + コンテンツ」となっています。ヘッダーには、Content-Dispositionという項目が含まれます。Dispositionは気質、性質といった英語で、大雑把にはContent-Typeのようなものです。ここでは、項目名付きでフォームのデータであると宣言しています。

```html
<form action="POST" enctype="multipart/form-data">
</form>
```

### text/plain
www-form-urlencodedに近いのですが、エスケープをせず、改行区切りで値を並べて送信します。

### キャッシュ
毎回ダウンロードしていてはすべて表示するまでにかなりの時間がかかります。すでにダウンロード済みで、内容に変化がなければダウンロードを抑制し、それによってパフォーマンスをあげるメカニズムが「キャッシュ」です。
必要以上にキャッシュされてしまうと、他の人向けのコンテンツが見えてしまうなど、設定を間違えるとセキュリティインシデントに繋がりかねないというリスクを孕んでいる危険な技術でもあります。
- **Expires**<br>
    更新日時を使ったキャッシュの場合、キャッシュの有効性を確認するために通信が発生します。その通信自体をなくしてしまう仕組みがHTTP/1.0に導入されました。それがExpiresヘッダーです。指定された期日以内の変更がすべて握りつぶされてしまい、新しいコンテンツを見ることが一切できなくなるから、スタイルシートなど、更新がめったに行われない静的コンテンツで使用するのが望ましいです。
- **ETag**<br>
    ETagはHTTPのレスポンスヘッダーで、リソースの特定バージョンの識別子です。ウェブサーバーは、コンテンツが変更されていない場合はレスポンス全体を再送する必要がないので、キャッシュがより効率的になり通信帯域を節約することができます。
- **Cache-Control**<br>
    より柔軟なキャッシュ制御をサーバー側から指示できます。Expiresよりも優先されます。
    - サーバーからレスポンスとして送付されるヘッダーについて
        - public → 同一のコンピュータを使う複数ユーザー間でキャッシュを再利用することを許可する
        - private → 同一のコンピュータを使う別のユーザー間でキャッシュを再利用しない。同じURLからユーザーごとに異なるコンテンツが返される場合に利用
        - max-age=n → キャッシュの鮮度を秒で設定。86400を指定すると、1日間はキャッシュが有効で、サーバーに問い合わせることなくキャッシュを利用する。それ以降はサーバーに問い合わせを行い、304 Not Modifiedが返ってきた時のみキャッシュを利用する
        - s-maxage=n → max-ageと同等だが、共有のキャッシュに対する設定値
        - no-cache → キャッシュが有効かどうか毎回サーバーに問い合わせる。max-age=0とほぼ同じ
        - no-store → キャッシュしない
    - クライアント側からリクエストヘッダーで使える設定値
        - no-cache → Pragma: no-cacheと同等
        - no-store → これはレスポンスのno-storeと同じで、プロキシサーバーにキャッシュを削除するように要請
        ‐ max-age → プロキシで保存されているキャッシュが最初に保存してから指定時間以上のキャッシュは使わないようプロキシに要請
        - max-stale → これは指定された時間だけ鮮度維持期間がすぎても、クライアントはそれを受け取ることをプロキシに要請。延長時間は省略でき、その場合は永遠に有効の意味になる
        - min-fresh →鮮度維持期間が指定された時間以上残っていれば、そのキャッシュを送信しても良いとプロキシに要請
        - no-transform → プロキシがコンテンツを改変するのを抑制するようプロキシに要請
        - only-if-cached → キャッシュしている場合のみ応答を返し、そうでなければ504 Gateway Timeoutを送信することをプロキシに要請する。これが設定されると、初回を除いてオリジンサーバーへのアクセスは一切行われない
